# Tivra DebugMind v0.3.0 - Feature Roadmap

## Overview
This document outlines the major features planned for v0.3.0, focusing on improved UX, security, and proactive monitoring.

---

## 🎯 Key Features for v0.3.0

### 1. **Auto-Discovery of AWS Services** ✅ (Backend Ready)

**Current State (v0.2.1-beta):**
- User must manually tell copilot which service to debug
- No visibility into what services exist in AWS account

**Planned Improvement:**
- After AWS connection, automatically discover all services
- Display list of discovered services in copilot
- Show service types (Lambda, ECS, EC2, etc.)
- If no services found, show helpful message

**Backend Endpoint (Already Exists):**
```
GET /api/aws/services/discover
Response: {
  services: [
    { name: "getUserById", type: "Lambda", logGroup: "/aws/lambda/getUserById" },
    { name: "api-server", type: "ECS", logGroup: "/ecs/api-server" },
    { name: "web-app-instance", type: "EC2", logGroup: "/ec2/web-app" }
  ]
}
```

**Frontend Implementation:**
```typescript
// After successful AWS connection
private async discoverServices() {
  const response = await axios.get(`${this._apiUrl}/api/aws/services/discover`);

  if (response.data.services.length === 0) {
    this.addMessage({
      type: 'ai',
      content: `⚠️ **No AWS services found**\n\nI couldn't find any Lambda, ECS, or EC2 services in your AWS account.\n\nPossible reasons:\n• Services might be in a different region\n• IAM permissions might be restricted\n• No services deployed yet\n\nWould you like to:\n• Check another region\n• Verify IAM permissions\n• Set up a test service`,
      suggestedPrompts: [
        'How do I change AWS region?',
        'What IAM permissions do I need?',
        'Help me deploy a test Lambda'
      ]
    });
  } else {
    this.addMessage({
      type: 'ai',
      content: `✅ **Discovered ${response.data.services.length} AWS services**\n\n` +
        response.data.services.map((s, i) =>
          `${i + 1}. **${s.name}** (${s.type})`
        ).join('\n') +
        `\n\nNow monitoring these services for errors. I'll notify you when issues are detected!`,
      suggestedPrompts: response.data.services.slice(0, 3).map(s =>
        `Show me errors in ${s.name}`
      )
    });

    // Start monitoring all services
    this.startMonitoring(response.data.services);
  }
}
```

---

### 2. **Continuous Error Polling & Proactive Notifications**

**Current State (v0.2.1-beta):**
- User must manually ask "Show me errors"
- No real-time monitoring
- No proactive error detection

**Planned Improvement:**
- After AWS connection, poll for errors every 30 seconds
- Auto-detect new errors in monitored services
- Proactively notify user in copilot when errors appear
- Show error trends (increasing/decreasing)

**Implementation:**

```typescript
export class DebugCopilot {
  private _monitoringInterval: NodeJS.Timeout | null = null;
  private _monitoredServices: Array<{ name: string; type: string }> = [];
  private _lastErrorCounts: Map<string, number> = new Map();

  /**
   * Start monitoring all discovered services
   */
  private startMonitoring(services: any[]) {
    this._monitoredServices = services;

    // Poll every 30 seconds
    this._monitoringInterval = setInterval(async () => {
      await this.pollForErrors();
    }, 30000);

    this.addMessage({
      type: 'system',
      content: `🔄 Started monitoring ${services.length} services. I'll alert you if I detect any errors.`,
      timestamp: new Date()
    });
  }

  /**
   * Poll for errors across all monitored services
   */
  private async pollForErrors() {
    for (const service of this._monitoredServices) {
      try {
        const response = await axios.post(`${this._apiUrl}/api/aws/logs/analyze`, {
          serviceName: service.name,
          serviceType: service.type,
          timeRange: {
            start: Date.now() - 60000, // Last 1 minute
            end: Date.now()
          }
        });

        const currentErrorCount = response.data.totalErrors;
        const previousCount = this._lastErrorCounts.get(service.name) || 0;

        // Check if new errors detected
        if (currentErrorCount > previousCount) {
          const newErrors = currentErrorCount - previousCount;

          // Proactive notification
          this.addMessage({
            type: 'ai',
            content: `🚨 **New errors detected in ${service.name}!**\n\n` +
              `• ${newErrors} new error(s) in the last minute\n` +
              `• Total errors now: ${currentErrorCount}\n\n` +
              `Would you like me to:\n` +
              `• Analyze the root cause\n` +
              `• Generate a fix\n` +
              `• Show error details`,
            timestamp: new Date(),
            suggestedPrompts: [
              `Analyze errors in ${service.name}`,
              `Generate fix for ${service.name}`,
              `Show error details`
            ]
          });

          // Play notification sound (if user enabled)
          vscode.window.showWarningMessage(
            `New errors detected in ${service.name}`,
            'Analyze',
            'Ignore'
          ).then(choice => {
            if (choice === 'Analyze') {
              this.startDebugging(service.name, service.type);
            }
          });
        }

        this._lastErrorCounts.set(service.name, currentErrorCount);
      } catch (error) {
        console.error(`Error polling ${service.name}:`, error);
      }
    }
  }

  /**
   * Stop monitoring (called on dispose or disconnect)
   */
  private stopMonitoring() {
    if (this._monitoringInterval) {
      clearInterval(this._monitoringInterval);
      this._monitoringInterval = null;

      this.addMessage({
        type: 'system',
        content: `⏸️ Stopped monitoring AWS services.`,
        timestamp: new Date()
      });
    }
  }

  public dispose() {
    this.stopMonitoring();
    // ... rest of dispose logic
  }
}
```

**User Experience:**
```
[User connects to AWS]

Copilot: "✅ Connected to AWS! Discovered 5 services.
Now monitoring: getUserById, createOrder, sendEmail, processPayment, api-gateway
I'll alert you if I detect any errors."

[30 seconds later - error detected]

Copilot: "🚨 New errors detected in getUserById!
• 3 new errors in the last minute
• Total errors now: 3

Would you like me to:
• Analyze the root cause
• Generate a fix
• Show error details"

[Prompts: "Analyze errors in getUserById", "Generate fix", "Show details"]
```

---

### 3. **Improved Prompts & Status Display**

**Current State (v0.2.1-beta):**
- Prompts show "Connect me to AWS" when not connected
- No indication of monitoring status

**Planned Improvement:**
- Clear status indicator in copilot header
- Different prompts based on connection + monitoring state
- Show which services are being monitored

**UI Changes:**

**Header Status Indicator:**
```html
<div class="header">
  <span>🤖</span>
  <div>
    <h2>Tivra DebugMind</h2>
    <div class="status" id="connectionStatus">
      <!-- Dynamic status based on state -->
    </div>
  </div>
</div>
```

**Status States:**

1. **Not Connected:**
```
Status: ⚠️ AWS Not Connected
Prompts: ["Connect me to AWS"]
```

2. **Connected, No Services:**
```
Status: ⚠️ AWS Connected • No Services Found
Prompts: ["Help me deploy a Lambda", "Change AWS region"]
```

3. **Connected, Monitoring:**
```
Status: ✅ AWS Connected • Monitoring 5 services
Prompts: ["Show me recent errors", "Which services are monitored?"]
```

4. **Connected, Errors Detected:**
```
Status: 🚨 AWS Connected • 3 services with errors
Prompts: ["Show me all errors", "Fix critical issues first"]
```

**Implementation:**
```typescript
private updateStatus(status: ConnectionStatus) {
  let statusText = '';
  let prompts: string[] = [];

  switch (status.state) {
    case 'disconnected':
      statusText = '⚠️ AWS Not Connected';
      prompts = ['Connect me to AWS'];
      break;

    case 'connected-no-services':
      statusText = `✅ AWS Connected (${status.region}) • No Services Found`;
      prompts = ['Help me deploy a Lambda', 'Change AWS region'];
      break;

    case 'monitoring':
      statusText = `✅ AWS Connected • Monitoring ${status.serviceCount} services`;
      prompts = ['Show me recent errors', 'Which services are monitored?'];
      break;

    case 'errors-detected':
      statusText = `🚨 AWS Connected • ${status.errorCount} services with errors`;
      prompts = ['Show me all errors', 'Fix critical issues first'];
      break;
  }

  // Update header
  this._panel.webview.postMessage({
    type: 'updateStatus',
    status: statusText
  });

  // Update suggested prompts
  this.updateSuggestedPrompts(prompts);
}
```

---

### 4. **AWS OAuth/SSO Integration (More Secure)**

**Current State (v0.2.1-beta):**
- Requires AWS Access Key ID + Secret Key
- Users hesitant to share credentials
- Credentials stored in backend (security concern)

**Problem:**
Users are rightfully concerned about sharing long-term credentials. This is a major barrier to adoption.

**Planned Solution: AWS Identity Center (SSO)**

**Benefits:**
- ✅ No long-term credentials needed
- ✅ Temporary session tokens (expires in 12 hours)
- ✅ Works with corporate SSO (Okta, Azure AD, etc.)
- ✅ Better security posture
- ✅ Easier revocation

**How AWS SSO Works:**

```
┌─────────────────────────────────────────────┐
│ User clicks "Connect with AWS SSO"          │
└────────────────┬────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────┐
│ VS Code opens browser to AWS SSO login      │
│ URL: https://YOUR-ORG.awsapps.com/start     │
└────────────────┬────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────┐
│ User logs in with corporate credentials     │
│ (Okta, Azure AD, Google, etc.)              │
└────────────────┬────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────┐
│ AWS generates temporary session token       │
│ - Access Key ID (temp)                      │
│ - Secret Access Key (temp)                  │
│ - Session Token                             │
│ - Expiration time (12 hours)                │
└────────────────┬────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────┐
│ Token sent back to VS Code extension        │
└────────────────┬────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────┐
│ Extension uses temp credentials for         │
│ CloudWatch API calls                        │
│ - No long-term secrets stored               │
│ - Auto-refresh before expiration            │
└─────────────────────────────────────────────┘
```

**Implementation Plan:**

**Option 1: AWS SSO (Best for Enterprise)**

**Backend Changes:**
```javascript
// server/routes/aws.js

// New endpoint: Start SSO flow
router.get('/sso/start', (req, res) => {
  // Generate state token for CSRF protection
  const state = crypto.randomBytes(16).toString('hex');

  // Store state in session
  sessions.set(state, { timestamp: Date.now() });

  // AWS SSO start URL
  const ssoUrl = `https://${process.env.AWS_SSO_START_URL}/start?` +
    `client_id=${process.env.AWS_SSO_CLIENT_ID}&` +
    `response_type=code&` +
    `state=${state}&` +
    `redirect_uri=${encodeURIComponent(process.env.AWS_SSO_REDIRECT_URI)}`;

  res.json({ ssoUrl, state });
});

// Callback endpoint after SSO login
router.get('/sso/callback', async (req, res) => {
  const { code, state } = req.query;

  // Verify state (CSRF protection)
  if (!sessions.has(state)) {
    return res.status(400).json({ error: 'Invalid state' });
  }
  sessions.delete(state);

  try {
    // Exchange code for tokens
    const tokenResponse = await fetch(`https://oidc.${process.env.AWS_REGION}.amazonaws.com/token`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code,
        client_id: process.env.AWS_SSO_CLIENT_ID,
        redirect_uri: process.env.AWS_SSO_REDIRECT_URI
      })
    });

    const tokens = await tokenResponse.json();

    // Get temporary AWS credentials
    const ssoClient = new SSOClient({ region: process.env.AWS_REGION });
    const credentialsResponse = await ssoClient.send(
      new GetRoleCredentialsCommand({
        roleName: process.env.AWS_SSO_ROLE_NAME,
        accountId: process.env.AWS_ACCOUNT_ID,
        accessToken: tokens.access_token
      })
    );

    // Store temporary credentials
    await writeStore({
      connected: true,
      region: process.env.AWS_REGION,
      credentials: {
        accessKeyId: credentialsResponse.roleCredentials.accessKeyId,
        secretAccessKey: credentialsResponse.roleCredentials.secretAccessKey,
        sessionToken: credentialsResponse.roleCredentials.sessionToken,
        expiration: credentialsResponse.roleCredentials.expiration
      },
      ssoAccessToken: tokens.access_token,
      ssoRefreshToken: tokens.refresh_token
    });

    // Redirect back to success page
    res.redirect('/sso-success.html');
  } catch (error) {
    console.error('SSO callback error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Auto-refresh credentials before expiration
setInterval(async () => {
  const store = await readStore();
  if (store.connected && store.credentials.expiration) {
    const expiresIn = store.credentials.expiration - Date.now();

    // Refresh if expiring in < 10 minutes
    if (expiresIn < 10 * 60 * 1000) {
      await refreshSSOCredentials(store.ssoRefreshToken);
    }
  }
}, 5 * 60 * 1000); // Check every 5 minutes
```

**Frontend Changes:**
```typescript
// src/panels/debugCopilot.ts

/**
 * Start AWS SSO connection flow
 */
private async startAWSSSOFlow() {
  this.addMessage({
    type: 'ai',
    content: `🔐 **Connect with AWS SSO**\n\nI'll open your browser for secure AWS login.\n\n` +
      `Benefits of SSO:\n` +
      `• ✅ No long-term credentials needed\n` +
      `• ✅ Works with your company's login (Okta, Azure AD, etc.)\n` +
      `• ✅ Temporary access (expires in 12 hours)\n` +
      `• ✅ More secure than Access Keys\n\n` +
      `Click below to continue:`,
    timestamp: new Date(),
    suggestedPrompts: [
      'Connect with AWS SSO',
      'Use Access Keys instead',
      'How does SSO work?'
    ]
  });
}

/**
 * Handle SSO connection
 */
private async connectWithSSO() {
  try {
    // Get SSO URL from backend
    const response = await axios.get(`${this._apiUrl}/api/aws/sso/start`);
    const { ssoUrl, state } = response.data;

    this.addMessage({
      type: 'system',
      content: `🌐 Opening AWS SSO login in your browser...`,
      timestamp: new Date()
    });

    // Open browser for SSO login
    await vscode.env.openExternal(vscode.Uri.parse(ssoUrl));

    // Poll for SSO completion
    const pollInterval = setInterval(async () => {
      try {
        const statusResponse = await axios.get(`${this._apiUrl}/api/aws/status`);

        if (statusResponse.data.connected) {
          clearInterval(pollInterval);

          this.addMessage({
            type: 'ai',
            content: `🎉 **Successfully connected via AWS SSO!**\n\n` +
              `Session valid for: 12 hours\n` +
              `Region: ${statusResponse.data.region}\n\n` +
              `Now discovering your AWS services...`,
            timestamp: new Date()
          });

          // Discover services
          await this.discoverServices();
        }
      } catch (error) {
        // Still waiting for SSO completion
      }
    }, 2000); // Poll every 2 seconds

    // Timeout after 5 minutes
    setTimeout(() => {
      clearInterval(pollInterval);
      this.addMessage({
        type: 'ai',
        content: `⏱️ **SSO login timed out**\n\n` +
          `Please try again or use Access Keys instead.`,
        timestamp: new Date(),
        suggestedPrompts: [
          'Try SSO again',
          'Use Access Keys instead'
        ]
      });
    }, 5 * 60 * 1000);

  } catch (error: any) {
    this.addMessage({
      type: 'ai',
      content: `❌ **Failed to start SSO flow**\n\n` +
        `Error: ${error.message}\n\n` +
        `Please try again or use Access Keys.`,
      timestamp: new Date(),
      suggestedPrompts: [
        'Try SSO again',
        'Use Access Keys instead'
      ]
    });
  }
}
```

**Option 2: AWS CLI Profile (Simpler Alternative)**

For users who already use AWS CLI:

```typescript
/**
 * Use AWS CLI credentials
 */
private async useAWSCLIProfile() {
  this.addMessage({
    type: 'ai',
    content: `📋 **Use AWS CLI Credentials**\n\n` +
      `If you have AWS CLI configured, I can use those credentials.\n\n` +
      `Available profiles:`,
    timestamp: new Date()
  });

  try {
    // Get AWS CLI profiles from backend
    const response = await axios.get(`${this._apiUrl}/api/aws/cli/profiles`);
    const profiles = response.data.profiles;

    if (profiles.length === 0) {
      this.addMessage({
        type: 'ai',
        content: `⚠️ No AWS CLI profiles found.\n\n` +
          `Please configure AWS CLI first:\n` +
          `\`\`\`bash\n` +
          `aws configure\n` +
          `\`\`\``,
        timestamp: new Date()
      });
      return;
    }

    this.addMessage({
      type: 'ai',
      content: `Found ${profiles.length} AWS CLI profile(s). Choose one:`,
      timestamp: new Date(),
      suggestedPrompts: profiles.map(p => `Use profile: ${p}`)
    });
  } catch (error: any) {
    this.addMessage({
      type: 'ai',
      content: `❌ Failed to read AWS CLI profiles: ${error.message}`,
      timestamp: new Date()
    });
  }
}
```

---

## 📋 Implementation Timeline

### Phase 1: Service Discovery & Monitoring (Week 1)
- [x] Backend: `/api/aws/services/discover` (Already exists!)
- [ ] Frontend: Call discovery after AWS connection
- [ ] Display discovered services in chat
- [ ] Handle "no services found" case
- [ ] Add polling mechanism
- [ ] Implement proactive error notifications

### Phase 2: Improved Prompts & Status (Week 1)
- [ ] Add status indicator to copilot header
- [ ] Dynamic status updates based on state
- [ ] Context-aware suggested prompts
- [ ] Show monitoring statistics

### Phase 3: AWS SSO Integration (Week 2-3)
- [ ] Research AWS SSO setup requirements
- [ ] Implement SSO flow in backend
- [ ] Add browser-based OAuth flow in frontend
- [ ] Handle token refresh
- [ ] Add CLI profile option as fallback
- [ ] Update documentation

### Phase 4: Testing & Polish (Week 3-4)
- [ ] E2E testing of SSO flow
- [ ] Test service discovery with various AWS accounts
- [ ] Test error polling accuracy
- [ ] Performance optimization
- [ ] User acceptance testing
- [ ] Documentation updates

---

## 🎯 Success Metrics

1. **Service Discovery**
   - 95% of users' services auto-discovered
   - < 5 seconds to discover and display services

2. **Error Detection**
   - Errors detected within 30 seconds of occurrence
   - < 5% false positive rate
   - 0 missed critical errors

3. **SSO Adoption**
   - 70%+ of new users choose SSO over Access Keys
   - < 1 minute to complete SSO flow
   - 0 SSO-related security issues

4. **User Satisfaction**
   - "AWS connection is easy" > 90% agreement
   - "I trust the security" > 95% agreement
   - "Monitoring is helpful" > 85% agreement

---

## 📝 Documentation Updates Needed

1. **Setup Guide**
   - How to configure AWS SSO
   - IAM permissions required
   - Troubleshooting common issues

2. **Security Best Practices**
   - Why SSO is recommended
   - How temporary credentials work
   - Token refresh mechanism

3. **User Guide**
   - How service discovery works
   - Understanding error notifications
   - Managing monitored services

---

## 🚧 Open Questions

1. **SSO Configuration**
   - Should we require AWS SSO setup or offer it as optional?
   - How to handle multi-account scenarios?
   - Support for AWS Organizations?

2. **Polling Frequency**
   - Is 30 seconds too frequent? (API costs)
   - Should polling frequency be configurable?
   - Should we use CloudWatch Alarms instead?

3. **Service Types**
   - Which AWS service types to support?
   - Lambda, ECS, EC2 - what else?
   - API Gateway? RDS? DynamoDB?

4. **Error Threshold**
   - When to trigger proactive notifications?
   - 1 error? 5 errors? Configurable?
   - Different thresholds for different service types?

---

## 💡 Future Ideas (v0.4.0+)

- **Multi-Cloud Support**: GCP, Azure integration
- **Custom Alerts**: User-defined error patterns
- **Error Trends**: Historical analysis with charts
- **Team Collaboration**: Share debugging sessions
- **Slack/Teams Integration**: Send alerts to team channels
- **GitHub Auto-PR**: Automatically create PRs with fixes
